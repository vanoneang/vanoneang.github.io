(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{492:function(e,t,n){"use strict";n.r(t);var o=n(10),s=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"closure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#closure"}},[e._v("#")]),e._v(" Closure")]),e._v(" "),t("p",[e._v("JavaScript 的"),t("strong",[e._v("作用域")]),e._v("通俗来讲，就是"),t("strong",[e._v("指变量能够被访问到的范围（The range of variables that can be accessed）")]),e._v("。分为全局作用域（Global scope）、函数作用域（Function scope）和块级作用域（Block scope）三种。")]),e._v(" "),t("p",[e._v("Closures are frequently used in JavaScript for object data privacy, in event handlers and callback functions, and in partial applications, currying, and other functional programming patterns.")]),e._v(" "),t("p",[e._v("闭包其实就是一个可以访问其他函数内部变量的"),t("strong",[e._v("函数")]),e._v("。All you need to know about closures is that "),t("strong",[e._v("when you have a function defined inside of another function that inner function has access to the variables and scope of the outer function. Even if the outer function finishes executing and those variables are no longer accessible outside that function.")])]),e._v(" "),t("h2",{attrs:{id:"what-is-a-closure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#what-is-a-closure"}},[e._v("#")]),e._v(" What is a Closure?")]),e._v(" "),t("p",[e._v("A closure is the combination of a function bundled together (enclosed) with reference to its surrounding state (the "),t("strong",[e._v("lexical environment")]),e._v("). In other words, a closure gives you access to an outer function's scope from an inner function.")]),e._v(" "),t("p",[e._v("Another thing to note is that if you define a function that uses global variables, this also produces a closure. The way closures work in JavaScript is that every scope has access to everything outside of its scope.")]),e._v(" "),t("vue-embed-gist",{attrs:{"gist-id":"f37f2bb5cfecd97d26b095c312552b64",file:"global-function-closure.js"}}),e._v(" "),t("p",[e._v("Generally, if the function referencing the closure is a global variable, then the closure will exist until the page is closed; but if the closure is no longer used, it will cause a "),t("strong",[e._v("memory leak")]),e._v(".")]),e._v(" "),t("p",[e._v("The inner function will have access to the variables in the outer function scope, even after the outer function has returned.")]),e._v(" "),t("h2",{attrs:{id:"闭包产生的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包产生的原因"}},[e._v("#")]),e._v(" 闭包产生的原因")]),e._v(" "),t("p",[e._v("当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。闭包产生的本质就是："),t("strong",[e._v("当前环境中存在指向父级作用域的引用")]),e._v("。")]),e._v(" "),t("ol",[t("li",[e._v("闭包的作用域链包含它自己的作用域、包含outer函数的作用域和全局作用域")]),e._v(" "),t("li",[e._v("通常，函数的作用域及其所有变量都会在函数执行结束后销毁")]),e._v(" "),t("li",[e._v("但是，当函数返回来了一个闭包，这个函数的作用域将一直在内存中保存在闭包不存在为止。")])]),e._v(" "),t("p",[e._v("[1] "),t("a",{attrs:{href:"https://segmentfault.com/a/1190000018445196",target:"_blank",rel:"noopener noreferrer"}},[e._v("防抖"),t("OutboundLink")],1)])],1)}),[],!1,null,null,null);t.default=s.exports}}]);